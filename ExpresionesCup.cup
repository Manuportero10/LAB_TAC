
import java_cup.runtime.*;
import java.io.*;

parser code {:
	public static void main(String args[]) throws Exception {

 		FileInputStream stream = new java.io.FileInputStream(args[0]);
       		Reader reader = new java.io.InputStreamReader(stream);

		try{
			new parser(new Yylex(reader)).parse();
		}
		catch ( Exception e) {
			System.out.println("Analisis INCORRECTO !!");
			System.exit(1);
		}
		System.out.println("Analisis Correcto ");
	
		}
:}

terminal PUBLIC, CLASS, MAIN, STATIC, VOID, FOR, WHILE, DO, VAR_TYPE, RETURN,
ID, ASSIGN, OP_ASSIGN, ARITHMETIC, RELATIONAL, LOGICAL, NUMERO, LOGICO, 
SEMICOLON, COMMA, OPEN_PARENTHESIS, CLOSE_PARENTHESIS, OPEN_BRACKET, CLOSE_BRACKET, IF;

non terminal def_class, lista_metodos, metodo, lista_args_cab, lista_args_llam, metodo_main, metodo_void, metodo_var,
retorno, llamada_func, lista_instr, def_var, assign, op_n_assign, bucle_for, bucle_while, expresion_if,
expr_ari,expr_log,do_while, lista_instr_void;

precedence left ARITHMETIC;

start with def_class;

def_class ::= PUBLIC CLASS ID OPEN_BRACKET lista_metodos CLOSE_BRACKET;

lista_metodos ::= metodo lista_metodos | /*vacio*/;


metodo ::= metodo_main 
		   | metodo_void 
		   | metodo_var;

lista_args_cab ::= VAR_TYPE ID COMMA lista_args_cab
				   | VAR_TYPE ID
				   | /*vacio*/;
				
lista_args_llam ::= LOGICO COMMA lista_args_llam
					| expr_ari COMMA lista_args_llam
					| LOGICO
					| expr_ari
					| llamada_func
					| /*vacio*/;


metodo_main ::= PUBLIC STATIC VOID MAIN OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACKET 
				lista_instr_void
				CLOSE_BRACKET;

metodo_void ::= PUBLIC STATIC VOID ID OPEN_PARENTHESIS lista_args_cab CLOSE_PARENTHESIS OPEN_BRACKET 
				lista_instr_void 
				CLOSE_BRACKET;

metodo_var ::= PUBLIC STATIC VAR_TYPE ID OPEN_PARENTHESIS lista_args_cab CLOSE_PARENTHESIS 
			   OPEN_BRACKET lista_instr
			   CLOSE_BRACKET;

retorno ::= RETURN expr_ari SEMICOLON
		   | RETURN expr_log SEMICOLON 
		   | RETURN llamada_func SEMICOLON;

llamada_func ::= ID OPEN_PARENTHESIS lista_args_llam CLOSE_PARENTHESIS
				| OPEN_PARENTHESIS ID OPEN_PARENTHESIS lista_args_llam CLOSE_PARENTHESIS CLOSE_PARENTHESIS
				| llamada_func SEMICOLON;

lista_instr ::= def_var lista_instr
			    | assign lista_instr 
				| bucle_for lista_instr 
				| op_n_assign lista_instr 
				| llamada_func lista_instr
				| bucle_while lista_instr
				| retorno lista_instr
				| expresion_if lista_instr
				| retorno;


lista_instr_void ::= def_var lista_instr_void 
			    | assign lista_instr_void 
				| bucle_for lista_instr_void 
				| op_n_assign lista_instr_void 
				| llamada_func lista_instr_void
				| bucle_while lista_instr_void
				| expresion_if lista_instr_void
				| /*vacio*/;
				
def_var ::= VAR_TYPE ID SEMICOLON 
		    | VAR_TYPE ID assign
		    | ID assign;

assign ::= ASSIGN expr_ari SEMICOLON 
		   | ASSIGN expr_log SEMICOLON 
		   | ASSIGN llamada_func SEMICOLON;

op_n_assign ::= ID OP_ASSIGN SEMICOLON;

bucle_for ::= FOR OPEN_PARENTHESIS VAR_TYPE ID ASSIGN NUMERO SEMICOLON 
		ID RELATIONAL expr_ari SEMICOLON  
		ID OP_ASSIGN CLOSE_PARENTHESIS OPEN_BRACKET 
		lista_instr_void 
		CLOSE_BRACKET |
		FOR OPEN_PARENTHESIS VAR_TYPE ID ASSIGN NUMERO SEMICOLON 
		ID RELATIONAL llamada_func SEMICOLON  
		ID OP_ASSIGN CLOSE_PARENTHESIS OPEN_BRACKET 
		lista_instr_void 
		CLOSE_BRACKET;
		 

bucle_while ::= WHILE OPEN_PARENTHESIS expr_log CLOSE_PARENTHESIS 
		  OPEN_BRACKET 
		  lista_instr_void 
		  CLOSE_BRACKET;

expresion_if ::= IF OPEN_PARENTHESIS expr_log CLOSE_PARENTHESIS 
       OPEN_BRACKET 
       lista_instr 
       CLOSE_BRACKET;
       

expr_ari ::= NUMERO 
             | ID
             | expr_ari ARITHMETIC expr_ari 
             | llamada_func ARITHMETIC expr_ari
             | expr_ari ARITHMETIC llamada_func 
             | OPEN_PARENTHESIS expr_ari CLOSE_PARENTHESIS;
             
expr_log ::= LOGICO;

