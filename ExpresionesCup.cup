
import java_cup.runtime.*;
import java.io.*;

parser code {:
	public static void main(String args[]) throws Exception {

 		FileInputStream stream = new java.io.FileInputStream(args[0]);
       		Reader reader = new java.io.InputStreamReader(stream);

		try{
			new parser(new Yylex(reader)).parse();
		}
		catch ( Exception e) {
			System.out.println("Analisis INCORRECTO !!");
			System.exit(1);
		}
		System.out.println("Analisis Correcto ");
	
		}
:}

terminal PUBLIC, CLASS, ID, OPEN_BRACKET, CLOSE_BRACKET,OPEN_PARENTHESIS,
CLOSE_PARENTHESIS,STATIC,VOID,MAIN,FOR,ASSIGN,OP_ASSIGN,VAR_TYPE,RETURN,COMMA,SEMICOLON;

terminal Integer NUMERO;
terminal Boolean LOGICO;

non terminal def_class, lista_metodos, metodo, lista_args_cab, lista_args_llam, metodo_main, metodo_void, metodo_var
retorno, llamada_func, lista_instr, def_var, assign, op_n_assign, bucle_for, bucle_while, expresion_if;

non terminal Integer expr_ari;
not terminal Boolean expr_log;

def_class ::= PUBLIC CLASS ID OPEN_BRACKET lista_metodos CLOSE_BRACKET;

lista_metodos ::= metodo lista_metodos 
				  | metodo;
				 

metodo ::= metodo_main 
		   | metodo_void 
		   | metodo_var;

lista_args_cab ::= VAR_TYPE ID COMMA lista_args
				   | VAR_TYPE ID;
				
lista_args_llam ::= ID COMMA lista_args_llam 
					| ID;

metodo_main ::= PUBLIC STATIC VOID MAIN OPEN_PARENTHESIS CLOSE_PARENTHESIS OPEN_BRACKET lista_instr CLOSE_BRACKET;

metodo_void ::= PUBLIC STATIC VOID ID OPEN_PARENTHESIS lista_args_cab CLOSE_PARENTHESIS OPEN_BRACKET lista_instr CLOSE_BRACKET;

metodo_var ::= PUBLIC STATIC VAR_TYPE ID OPEN_PARENTHESIS lista_args_cab CLOSE_PARENTHESIS OPEN_BRACKET lista_instr retorno CLOSE_BRACKET;

retorno ::= RETURN expr_ari SEMICOLON 
		   | RETURN expr_log SEMICOLON 
		   | RETURN llamada_func SEMICOLON;

llamada_func ::= ID OPEN_PARENTHESIS lista_args_llam CLOSE_PARENTHESIS;

lista_instr ::= def_var lista_instr 
			    | assign lista_instr 
				| bucle_for lista_instr 
				| op_n_assign lista_instr 
				| llamada_func lista_instr
				| def_var 
				| assign 
				| bucle_for 
				| op_n_assign 
				| llamada_func 
				| bucle_while 
				| expresion_if;
				
def_var ::= VAR_TYPE ID SEMICOLON 
		    | VAR_TYPE assign;

assign ::= ID ASSIGN expr_ari SEMICOLON 
		   | ID ASSIGN expr_log SEMICOLON 
		   | ID ASSIGN llamada_func SEMICOLON;

op_n_assign ::= ID OP_ASSIGN SEMICOLON;

bucle_for ::= FOR OPEN_PARENTHESIS VAR_TYPE ID ASSIGN NUMERO SEMICOLON 
		ID RELATIONAL ID SEMICOLON  
		ID OP_ASSIGN CLOSE_PARENTHESIS OPEN_BRACKET 
		lista_instr 
		CLOSE_BRACKET; 

bucle_while ::= WHILE OPEN_PARENTHESIS expr_log CLOSE_PARENTHESIS 
		  OPEN_BRACKET 
		  lista_instr 
		  CLOSE_BRACKET;

expresion_if ::= IF OPEN_PARENTHESIS expr_log CLOSE_PARENTHESIS 
       OPEN_BRACKET 
       lista_instr 
       CLOSE_BRACKET;

Integer expr_ari ::= NUMERO 
                	 | ID
                	 | expr_ari ARITHMETIC expr_ari 
                	 | OPEN_PARENTHESIS expr_ari CLOSE_PARENTHESIS;

